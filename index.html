<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starfield Sopwith</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
            touch-action: manipulation;
            color: #fff;
        }
        #gameCanvas {
            display: block;
            background-color: #000;
        }
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            text-align: center;
            z-index: 10;
        }
        #gameOverScreen {
            display: none;
        }
        h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #4fc3f7;
            text-shadow: 0 0 10px rgba(79, 195, 247, 0.7);
            font-weight: 300;
            letter-spacing: 2px;
        }
        button {
            background: linear-gradient(135deg, #4fc3f7 0%, #0288d1 100%);
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 30px;
            margin: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(79, 195, 247, 0.5);
            position: relative;
            overflow: hidden;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.8);
        }
        button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                transparent 45%,
                rgba(255, 255, 255, 0.3) 50%,
                transparent 55%
            );
            transform: rotate(30deg);
            animation: shine 3s infinite;
        }
        @keyframes shine {
            0% { transform: translateX(-100%) rotate(30deg); }
            100% { transform: translateX(100%) rotate(30deg); }
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
            z-index: 5;
        }
        .control-btn {
            background: rgba(20, 30, 50, 0.7);
            color: white;
            border: 1px solid #4fc3f7;
            padding: 15px;
            font-size: 1rem;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
            transition: all 0.2s;
        }
        .control-btn:active {
            background: rgba(79, 195, 247, 0.3);
            transform: scale(0.95);
        }
        #scoreDisplay, #healthDisplay {
            position: absolute;
            color: white;
            font-size: 1.3rem;
            background: rgba(20, 30, 50, 0.5);
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid #4fc3f7;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.3);
            z-index: 5;
        }
        #scoreDisplay {
            top: 30px;
            left: 30px;
        }
        #healthDisplay {
            top: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        .health-bar {
            height: 8px;
            width: 150px;
            background-color: rgba(244, 67, 54, 0.3);
            margin-top: 8px;
            border-radius: 4px;
            overflow: hidden;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #f44336 0%, #4caf50 100%);
            border-radius: 4px;
            width: 100%;
            transition: width 0.3s;
        }
        .info-text {
            font-size: 1rem;
            color: #b0bec5;
            margin: 5px 0;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        .starfield-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="starfield-overlay" id="starfield"></div>
    <canvas id="gameCanvas"></canvas>
    
    <div id="startScreen">
        <h1>STARFIELD SOPWITH</h1>
        <p class="info-text">Intercept enemy vessels and protect the frontier</p>
        <button id="startButton">ENGAGE</button>
        <div style="margin-top: 20px;">
            <p class="info-text">Controls:</p>
            <p class="info-text">Left/Right to steer</p>
            <p class="info-text">Up to accelerate</p>
            <p class="info-text">Space to fire</p>
            <p class="info-text">Or use control panel below</p>
        </div>
    </div>
    
    <div id="gameOverScreen">
        <h1>MISSION FAILED</h1>
        <p class="info-text" id="finalScore">Score: 0</p>
        <button id="restartButton">RETRY</button>
    </div>
    
    <div id="scoreDisplay">CREDITS: 0</div>
    <div id="healthDisplay">
        SHIELD INTEGRITY
        <div class="health-bar">
            <div class="health-fill" id="healthFill"></div>
        </div>
    </div>
    
    <div id="controls">
        <button class="control-btn" id="leftBtn">←</button>
        <button class="control-btn" id="upBtn">↑</button>
        <button class="control-btn" id="rightBtn">→</button>
        <button class="control-btn" id="shootBtn">FIRE</button>
    </div>

    <script>
        // Telegram Web App initialization
        const tg = window.Telegram.WebApp;
        tg.expand();
        
        // Game constants
        const GRAVITY = 0.15;
        const THRUST = 0.2;
        const ROTATION_SPEED = 3.5;
        const BULLET_SPEED = 12;
        const ENEMY_SPAWN_RATE = 90;
        const BUILDING_SPAWN_RATE = 180;
        const CLOUD_SPAWN_RATE = 40;
        const STAR_COUNT = 500;
        
        // Game variables
        let canvas, ctx;
        let gameRunning = false;
        let score = 0;
        let health = 100;
        let stars = [];
        let plane = {
            x: 100,
            y: 300,
            width: 50,
            height: 35,
            speedX: 0,
            speedY: 0,
            angle: 0,
            cooldown: 0,
            engineOn: false
        };
        
        let bullets = [];
        let enemies = [];
        let buildings = [];
        let clouds = [];
        let explosions = [];
        let particles = [];
        let keys = {};
        let lastEnemySpawn = 0;
        let lastBuildingSpawn = 0;
        let lastCloudSpawn = 0;
        let gameTime = 0;
        let scrollX = 0;
        let starfieldElement;
        
        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            starfieldElement = document.getElementById('starfield');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize starfield background
            initStars();
            
            // Event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Button listeners
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('restartButton').addEventListener('click', startGame);
            
            // Touch controls
            setupControlButton('leftBtn', 'ArrowLeft');
            setupControlButton('rightBtn', 'ArrowRight');
            setupControlButton('upBtn', 'ArrowUp');
            setupControlButton('shootBtn', ' ');
        }
        
        function setupControlButton(btnId, key) {
            const btn = document.getElementById(btnId);
            
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
                if (key === 'ArrowUp') plane.engineOn = true;
            });
            
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
                if (key === 'ArrowUp') plane.engineOn = false;
            });
            
            btn.addEventListener('mousedown', () => {
                keys[key] = true;
                if (key === 'ArrowUp') plane.engineOn = true;
            });
            
            btn.addEventListener('mouseup', () => {
                keys[key] = false;
                if (key === 'ArrowUp') plane.engineOn = false;
            });
        }
        
        // Resize canvas to fit window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initStars(); // Reinitialize stars on resize
        }
        
        // Initialize starfield background
        function initStars() {
            stars = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 0.5 + 0.1,
                    alpha: Math.random() * 0.5 + 0.5
                });
            }
            
            // Update starfield HTML element
            starfieldElement.innerHTML = '';
            stars.forEach(star => {
                const starEl = document.createElement('div');
                starEl.style.position = 'absolute';
                starEl.style.width = `${star.size}px`;
                starEl.style.height = `${star.size}px`;
                starEl.style.backgroundColor = 'white';
                starEl.style.borderRadius = '50%';
                starEl.style.left = `${star.x}px`;
                starEl.style.top = `${star.y}px`;
                starEl.style.opacity = star.alpha;
                starEl.style.boxShadow = `0 0 ${star.size * 2}px white`;
                starEl.style.transform = 'translate(-50%, -50%)';
                starEl.style.transition = 'transform 0.1s linear';
                starfieldElement.appendChild(starEl);
            });
        }
        
        // Handle keyboard input
        function handleKeyDown(e) {
            keys[e.key] = true;
            if (e.key === 'ArrowUp') plane.engineOn = true;
        }
        
        function handleKeyUp(e) {
            keys[e.key] = false;
            if (e.key === 'ArrowUp') plane.engineOn = false;
        }
        
        // Start game
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            
            // Reset game state
            score = 0;
            health = 100;
            updateScore();
            updateHealth();
            
            plane = {
                x: 100,
                y: 300,
                width: 50,
                height: 35,
                speedX: 0,
                speedY: 0,
                angle: 0,
                cooldown: 0,
                engineOn: false
            };
            
            bullets = [];
            enemies = [];
            buildings = [];
            clouds = [];
            explosions = [];
            particles = [];
            keys = {};
            lastEnemySpawn = 0;
            lastBuildingSpawn = 0;
            lastCloudSpawn = 0;
            gameTime = 0;
            scrollX = 0;
            
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = `CREDITS: ${score}`;
            document.getElementById('gameOverScreen').style.display = 'flex';
            
            // Send score to Telegram bot if in Web App
            if (tg.initDataUnsafe?.user?.id) {
                tg.sendData(JSON.stringify({ score: score }));
            }
        }
        
        // Main game loop
        function gameLoop() {
            if (!gameRunning) return;
            
            update();
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Update game state
        function update() {
            gameTime++;
            
            // Update plane
            if (keys.ArrowLeft) {
                plane.angle -= ROTATION_SPEED;
            }
            if (keys.ArrowRight) {
                plane.angle += ROTATION_SPEED;
            }
            
            // Limit rotation
            plane.angle = Math.max(-45, Math.min(45, plane.angle));
            
            // Apply thrust when up is pressed
            if (keys.ArrowUp) {
                const rad = (plane.angle * Math.PI) / 180;
                plane.speedX += Math.sin(rad) * THRUST;
                plane.speedY -= Math.cos(rad) * THRUST;
                
                // Add engine particles
                if (gameTime % 3 === 0) {
                    particles.push({
                        x: plane.x - 10,
                        y: plane.y + plane.height / 2,
                        size: Math.random() * 4 + 2,
                        speedX: plane.speedX * 0.5 - 2 - Math.random() * 2,
                        speedY: plane.speedY * 0.5 + (Math.random() - 0.5) * 2,
                        color: `hsl(${Math.random() * 20 + 20}, 100%, 50%)`,
                        life: 20 + Math.random() * 10
                    });
                }
            }
            
            // Apply gravity
            plane.speedY += GRAVITY;
            
            // Update position
            plane.x += plane.speedX;
            plane.y += plane.speedY;
            
            // Screen wrapping
            if (plane.y < 0) plane.y = 0;
            if (plane.y > canvas.height - plane.height) {
                plane.y = canvas.height - plane.height;
                plane.speedY = 0;
            }
            
            // Shooting
            if (plane.cooldown > 0) {
                plane.cooldown--;
            }
            
            if (keys[' '] && plane.cooldown === 0) {
                shoot();
                plane.cooldown = 8;
            }
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bullets[i].speedX;
                bullets[i].y += bullets[i].speedY;
                
                // Remove bullets that are off screen
                if (bullets[i].x > canvas.width || bullets[i].x < 0 || 
                    bullets[i].y > canvas.height || bullets[i].y < 0) {
                    bullets.splice(i, 1);
                }
            }
            
            // Spawn enemies
            if (gameTime - lastEnemySpawn > ENEMY_SPAWN_RATE) {
                spawnEnemy();
                lastEnemySpawn = gameTime;
            }
            
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].x -= enemies[i].speed;
                
                // Check collision with bullets
                for (let j = bullets.length - 1; j >= 0; j--) {
                    if (checkCollision(bullets[j], enemies[i])) {
                        // Create explosion
                        createExplosion(
                            enemies[i].x + enemies[i].width / 2,
                            enemies[i].y + enemies[i].height / 2,
                            25
                        );
                        
                        // Remove bullet and enemy
                        bullets.splice(j, 1);
                        enemies.splice(i, 1);
                        
                        // Increase score
                        score += 15;
                        updateScore();
                        break;
                    }
                }
                
                // Remove enemies that are off screen
                if (enemies[i].x < -enemies[i].width) {
                    enemies.splice(i, 1);
                }
            }
            
            // Spawn buildings
            if (gameTime - lastBuildingSpawn > BUILDING_SPAWN_RATE) {
                spawnBuilding();
                lastBuildingSpawn = gameTime;
            }
            
            // Update buildings (scrolling)
            for (let i = buildings.length - 1; i >= 0; i--) {
                buildings[i].x -= 2;
                
                // Check collision with plane
                if (checkCollision(plane, buildings[i])) {
                    takeDamage(15);
                }
                
                // Remove buildings that are off screen
                if (buildings[i].x < -buildings[i].width) {
                    buildings.splice(i, 1);
                }
            }
            
            // Spawn clouds (nebulas)
            if (gameTime - lastCloudSpawn > CLOUD_SPAWN_RATE) {
                spawnCloud();
                lastCloudSpawn = gameTime;
            }
            
            // Update clouds
            for (let i = clouds.length - 1; i >= 0; i--) {
                clouds[i].x -= clouds[i].speed;
                
                // Remove clouds that are off screen
                if (clouds[i].x < -clouds[i].width) {
                    clouds.splice(i, 1);
                }
            }
            
            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].life--;
                if (explosions[i].life <= 0) {
                    explosions.splice(i, 1);
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].speedX;
                particles[i].y += particles[i].speedY;
                particles[i].life--;
                
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Check if plane hit the ground or ceiling
            if (plane.y <= 0 || plane.y >= canvas.height - plane.height) {
                takeDamage(2);
            }
            
            // Update star positions (parallax effect)
            updateStars();
        }
        
        // Render game
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw space gradient
            const spaceGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            spaceGradient.addColorStop(0, '#020210');
            spaceGradient.addColorStop(1, '#000033');
            ctx.fillStyle = spaceGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw distant galaxies (as part of the background)
            drawNebulas();
            
            // Draw buildings
            for (const building of buildings) {
                drawBuilding(building.x, building.y, building.width, building.height);
            }
            
            // Draw clouds (nebulas)
            for (const cloud of clouds) {
                drawCloud(cloud.x, cloud.y, cloud.width, cloud.height, cloud.color);
            }
            
            // Draw enemies
            for (const enemy of enemies) {
                drawEnemy(enemy.x, enemy.y, enemy.width, enemy.height);
            }
            
            // Draw bullets
            for (const bullet of bullets) {
                drawBullet(bullet.x, bullet.y);
            }
            
            // Draw particles
            for (const particle of particles) {
                drawParticle(particle);
            }
            
            // Draw explosions
            for (const explosion of explosions) {
                drawExplosion(explosion.x, explosion.y, explosion.radius, explosion.life / explosion.maxLife);
            }
            
            // Draw plane
            drawPlane(plane.x, plane.y, plane.width, plane.height, plane.angle, plane.engineOn);
        }
        
        // Draw plane with Starfield style
        function drawPlane(x, y, width, height, angle, engineOn) {
            ctx.save();
            ctx.translate(x + width / 2, y + height / 2);
            ctx.rotate((angle * Math.PI) / 180);
            
            // Plane body (futuristic design)
            ctx.fillStyle = '#e0f7fa';
            ctx.beginPath();
            ctx.moveTo(-width / 2, 0);
            ctx.lineTo(width / 3, -height / 3);
            ctx.lineTo(width / 2, 0);
            ctx.lineTo(width / 3, height / 3);
            ctx.closePath();
            ctx.fill();
            
            // Cockpit glass
            ctx.fillStyle = 'rgba(79, 195, 247, 0.6)';
            ctx.beginPath();
            ctx.arc(width / 6, 0, height / 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Engine glow
            if (engineOn) {
                const gradient = ctx.createLinearGradient(-width / 2, 0, -width, 0);
                gradient.addColorStop(0, 'rgba(255, 100, 50, 0.8)');
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(-width / 2, -height / 6);
                ctx.lineTo(-width, -height / 6);
                ctx.lineTo(-width, height / 6);
                ctx.lineTo(-width / 2, height / 6);
                ctx.closePath();
                ctx.fill();
            }
            
            // Wing details
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width / 4, -height / 3);
            ctx.lineTo(width / 2, -height / 4);
            ctx.moveTo(width / 4, height / 3);
            ctx.lineTo(width / 2, height / 4);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Draw enemy ship
        function drawEnemy(x, y, width, height) {
            ctx.save();
            ctx.translate(x + width / 2, y + height / 2);
            
            // Enemy body (alien design)
            ctx.fillStyle = '#f44336';
            ctx.beginPath();
            ctx.moveTo(-width / 2, 0);
            ctx.lineTo(0, -height / 2);
            ctx.lineTo(width / 2, 0);
            ctx.lineTo(0, height / 2);
            ctx.closePath();
            ctx.fill();
            
            // Glowing core
            const gradient = ctx.createRadialGradient(0, 0, 5, 0, 0, height / 4);
            gradient.addColorStop(0, '#ffeb3b');
            gradient.addColorStop(1, 'rgba(255, 235, 59, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, height / 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Energy shield effect
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, width / 2 + 2, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Draw bullet
        function drawBullet(x, y) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 5);
            gradient.addColorStop(0, '#ffeb3b');
            gradient.addColorStop(1, 'rgba(255, 235, 59, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw futuristic building
        function drawBuilding(x, y, width, height) {
            // Base
            ctx.fillStyle = '#263238';
            ctx.fillRect(x, y, width, height);
            
            // Glowing windows
            ctx.fillStyle = '#4fc3f7';
            const windowWidth = width / 6;
            const windowHeight = height / 12;
            const windowSpacing = windowWidth * 1.5;
            
            for (let wy = y + 15; wy < y + height - 15; wy += windowSpacing) {
                for (let wx = x + 10; wx < x + width - 10; wx += windowSpacing) {
                    // Random window glow
                    if (Math.random() > 0.3) {
                        const gradient = ctx.createRadialGradient(
                            wx + windowWidth / 2, 
                            wy + windowHeight / 2, 
                            0,
                            wx + windowWidth / 2, 
                            wy + windowHeight / 2, 
                            windowWidth
                        );
                        gradient.addColorStop(0, '#4fc3f7');
                        gradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(wx, wy, windowWidth, windowHeight);
                    }
                }
            }
            
            // Antenna
            ctx.fillStyle = '#37474f';
            ctx.fillRect(x + width / 2 - 3, y - 30, 6, 30);
            
            // Antenna glow
            ctx.fillStyle = '#ff9800';
            ctx.beginPath();
            ctx.arc(x + width / 2, y - 30, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw nebula cloud
        function drawCloud(x, y, width, height, color) {
            ctx.save();
            ctx.globalAlpha = 0.3;
            
            const segments = 7;
            const segmentWidth = width / segments;
            const hue = parseInt(color.split(',')[0].split('(')[1]);
            
            for (let i = 0; i < segments; i++) {
                const segmentX = x + i * segmentWidth;
                const segmentY = y + Math.sin(i * 0.5) * (height / 4);
                const segmentHeight = height * (0.7 + Math.sin(i * 0.8) * 0.3);
                
                const gradient = ctx.createRadialGradient(
                    segmentX + segmentWidth / 2,
                    segmentY + segmentHeight / 2,
                    0,
                    segmentX + segmentWidth / 2,
                    segmentY + segmentHeight / 2,
                    segmentWidth
                );
                
                gradient.addColorStop(0, `hsla(${hue}, 100%, 70%, 0.8)`);
                gradient.addColorStop(1, `hsla(${hue}, 100%, 50%, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(
                    segmentX + segmentWidth / 2,
                    segmentY + segmentHeight / 2,
                    segmentWidth / 2,
                    segmentHeight / 2,
                    0, 0, Math.PI * 2
                );
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // Draw explosion
        function drawExplosion(x, y, radius, intensity) {
            const outerRadius = radius * intensity;
            const innerRadius = outerRadius * 0.6;
            
            // Outer explosion
            const outerGradient = ctx.createRadialGradient(
                x, y, 0,
                x, y, outerRadius
            );
            outerGradient.addColorStop(0, `rgba(255, ${Math.floor(100 + 155 * intensity)}, 0, ${intensity})`);
            outerGradient.addColorStop(1, `rgba(255, 0, 0, 0)`);
            
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(x, y, outerRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner core
            const innerGradient = ctx.createRadialGradient(
                x, y, 0,
                x, y, innerRadius
            );
            innerGradient.addColorStop(0, `rgba(255, 255, 255, ${intensity * 0.8})`);
            innerGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
            
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(x, y, innerRadius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw particle
        function drawParticle(particle) {
            ctx.globalAlpha = particle.life / 30;
            ctx.fillStyle = particle.color;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        
        // Draw distant galaxies/nebulas
        function drawNebulas() {
            ctx.save();
            ctx.globalAlpha = 0.1;
            
            // Large background nebula 1
            const nebula1Gradient = ctx.createRadialGradient(
                canvas.width * 0.3, canvas.height * 0.2, 0,
                canvas.width * 0.3, canvas.height * 0.2, canvas.width * 0.5
            );
            nebula1Gradient.addColorStop(0, 'rgba(100, 50, 255, 0.8)');
            nebula1Gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = nebula1Gradient;
            ctx.beginPath();
            ctx.arc(canvas.width * 0.3, canvas.height * 0.2, canvas.width * 0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Large background nebula 2
            const nebula2Gradient = ctx.createRadialGradient(
                canvas.width * 0.7, canvas.height * 0.8, 0,
                canvas.width * 0.7, canvas.height * 0.8, canvas.width * 0.4
            );
            nebula2Gradient.addColorStop(0, 'rgba(255, 100, 200, 0.6)');
            nebula2Gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = nebula2Gradient;
            ctx.beginPath();
            ctx.arc(canvas.width * 0.7, canvas.height * 0.8, canvas.width * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Update star positions for parallax effect
        function updateStars() {
            const starElements = starfieldElement.children;
            
            for (let i = 0; i < stars.length; i++) {
                const star = stars[i];
                star.x -= star.speed * plane.speedX * 0.1;
                
                // Wrap stars around
                if (star.x < -10) star.x = canvas.width + 10;
                if (star.x > canvas.width + 10) star.x = -10;
                if (star.y < -10) star.y = canvas.height + 10;
                if (star.y > canvas.height + 10) star.y = -10;
                
                // Update DOM element position
                if (starElements[i]) {
                    starElements[i].style.left = `${star.x}px`;
                    starElements[i].style.top = `${star.y}px`;
                }
            }
        }
        
        // Spawn enemy
        function spawnEnemy() {
            const height = 40 + Math.random() * 30;
            const width = height * 0.9;
            
            enemies.push({
                x: canvas.width,
                y: Math.random() * (canvas.height - height - 100) + 50,
                width: width,
                height: height,
                speed: 3 + Math.random() * 2
            });
        }
        
        // Spawn building
        function spawnBuilding() {
            const height = 150 + Math.random() * 250;
            const width = 50 + Math.random() * 70;
            
            buildings.push({
                x: canvas.width,
                y: canvas.height - height,
                width: width,
                height: height
            });
        }
        
        // Spawn cloud (nebula)
        function spawnCloud() {
            const width = 150 + Math.random() * 200;
            const height = 50 + Math.random() * 80;
            const hue = Math.random() * 60 + 240; // Purple/blue colors
            
            clouds.push({
                x: canvas.width,
                y: Math.random() * (canvas.height / 2),
                width: width,
                height: height,
                speed: 0.3 + Math.random() * 0.7,
                color: `hsla(${hue}, 80%, 60%, 0.3)`
            });
        }
        
        // Create explosion effect
        function createExplosion(x, y, radius) {
            explosions.push({
                x: x,
                y: y,
                radius: radius,
                life: 30,
                maxLife: 30
            });
            
            // Create particles
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x,
                    y: y,
                    size: Math.random() * 5 + 2,
                    speedX: (Math.random() - 0.5) * 8,
                    speedY: (Math.random() - 0.5) * 8,
                    color: `hsl(${Math.random() * 30 + 20}, 100%, 50%)`,
                    life: 30 + Math.random() * 30
                });
            }
        }
        
        // Shoot bullet
        function shoot() {
            const rad = (plane.angle * Math.PI) / 180;
            const bulletX = plane.x + plane.width / 2 + Math.sin(rad) * 25;
            const bulletY = plane.y + plane.height / 2 - Math.cos(rad) * 25;
            
            bullets.push({
                x: bulletX,
                y: bulletY,
                speedX: plane.speedX + Math.sin(rad) * BULLET_SPEED,
                speedY: plane.speedY - Math.cos(rad) * BULLET_SPEED
            });
        }
        
        // Check collision between two objects
        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }
        
        // Take damage
        function takeDamage(amount) {
            health -= amount;
            updateHealth();
            
            // Create small explosion
            createExplosion(
                plane.x + plane.width / 2,
                plane.y + plane.height / 2,
                15
            );
            
            // Screen shake effect
            canvas.style.transform = 'translate(5px, 5px)';
            setTimeout(() => {
                canvas.style.transform = 'translate(0, 0)';
            }, 50);
            
            if (health <= 0) {
                // Create big explosion
                createExplosion(
                    plane.x + plane.width / 2,
                    plane.y + plane.height / 2,
                    40
                );
                
                gameOver();
            }
        }
        
        // Update score display
        function updateScore() {
            document.getElementById('scoreDisplay').textContent = `CREDITS: ${score}`;
        }
        
        // Update health display
        function updateHealth() {
            const healthFill = document.getElementById('healthFill');
            const percent = Math.max(0, health) / 100;
            healthFill.style.width = `${percent * 100}%`;
            
            // Pulsate effect when health is low
            if (percent < 0.3) {
                healthFill.style.animation = 'pulse 0.5s infinite alternate';
            } else {
                healthFill.style.animation = 'none';
            }
        }
        
        // Initialize game when loaded
        window.onload = init;
    </script>
</body>
</html>