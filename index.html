<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Cow Hunt</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #001a33 0%, #003366 100%);
            font-family: 'Arial', sans-serif;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #gameCanvas {
            display: block;
            background-color: #000033;
        }
        
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 20, 40, 0.8);
            color: #aaccff;
            text-align: center;
        }
        
        #gameOverScreen {
            display: none;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #3399ff;
            color: #66b3ff;
        }
        
        p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            max-width: 80%;
        }
        
        button {
            background: linear-gradient(180deg, #0066cc 0%, #003366 100%);
            border: 2px solid #3399ff;
            border-radius: 10px;
            color: #e6f2ff;
            padding: 12px 25px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(51, 153, 255, 0.5);
        }
        
        button:hover {
            background: linear-gradient(180deg, #0099ff 0%, #0066cc 100%);
            transform: scale(1.05);
        }
        
        #scoreDisplay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #aaccff;
            font-size: 1.5rem;
            text-shadow: 0 0 5px #3399ff;
            z-index: 100;
        }
        
        #ammoDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #aaccff;
            font-size: 1.5rem;
            text-shadow: 0 0 5px #3399ff;
            z-index: 100;
        }
        
        .crosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 99;
            display: none;
        }
    </style>
</head>
<body>
    <div id="scoreDisplay">Score: 0</div>
    <div id="ammoDisplay">Ammo: ∞</div>
    <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMCAzMCI+PGNpcmNsZSBjeD0iMTUiIGN5PSIxNSIgcj0iMTAiIHN0cm9rZT0iIzMzOTlmZiIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIi8+PGxpbmUgeDE9IjE1IiB5MT0iNSIgeDI9IjE1IiB5Mj0iMjUiIHN0cm9rZT0iIzMzOTlmZiIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjUiIHkxPSIxNSIgeDI9IjI1IiB5Mj0iMTUiIHN0cm9rZT0iIzMzOTlmZiIgc3Ryb2tlLXdpZHRoPSIyIi8+PC9zdmc+" class="crosshair" id="crosshair">
    <canvas id="gameCanvas"></canvas>
    
    <div id="startScreen">
        <h1>Cosmic Cow Hunt</h1>
        <p>Defend the space station from invading cows in spacesuits! Tap to shoot.</p>
        <button id="startButton">Start Mission</button>
    </div>
    
    <div id="gameOverScreen">
        <h1>Mission Failed</h1>
        <p id="finalScoreText">You scored: 0 points</p>
        <button id="restartButton">Try Again</button>
    </div>

    <script>
        // Telegram Web App initialization
        const tg = window.Telegram.WebApp;
        tg.expand();
        
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const ammoDisplay = document.getElementById('ammoDisplay');
        const crosshair = document.getElementById('crosshair');
        
        let score = 0;
        let ammo = Infinity;
        let gameRunning = false;
        let cows = [];
        let explosions = [];
        let lastCowTime = 0;
        let cowInterval = 1500;
        let difficultyIncreaseInterval = 10000;
        let lastDifficultyIncrease = 0;
        let backgroundStars = [];
        let spaceStations = [];
        let shots = [];
        let gameStartTime = 0;
        
        // Resize canvas to full window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Reinitialize background stars when canvas resizes
            initBackground();
        }
        
        // Initialize background stars
        function initBackground() {
            backgroundStars = [];
            const starCount = Math.floor(canvas.width * canvas.height / 1000);
            
            for (let i = 0; i < starCount; i++) {
                backgroundStars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 1.5 + 0.5,
                    brightness: Math.random() * 0.5 + 0.5,
                    speed: Math.random() * 0.2 + 0.1
                });
            }
            
            // Create space stations in the background
            spaceStations = [];
            for (let i = 0; i < 3; i++) {
                spaceStations.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.5,
                    size: Math.random() * 50 + 50,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: Math.random() * 0.01 - 0.005
                });
            }
        }
        
        // Cow class
        class Cow {
            constructor() {
                this.size = Math.random() * 40 + 40;
                this.x = Math.random() * (canvas.width - this.size);
                this.y = canvas.height + this.size;
                this.speedX = Math.random() * 4 - 2;
                this.speedY = Math.random() * -3 - 3;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = Math.random() * 0.02 - 0.01;
                this.hit = false;
                this.frame = 0;
                this.maxFrames = 4;
                this.animationSpeed = Math.floor(Math.random() * 5) + 5;
                this.frameCount = 0;
                
                // Random cow color variation
                this.colorVariation = Math.floor(Math.random() * 3);
            }
            
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.rotation += this.rotationSpeed;
                
                // Animation
                this.frameCount++;
                if (this.frameCount >= this.animationSpeed) {
                    this.frame = (this.frame + 1) % this.maxFrames;
                    this.frameCount = 0;
                }
                
                // Apply gravity if hit
                if (this.hit) {
                    this.speedY += 0.1;
                    this.rotationSpeed *= 1.02;
                }
                
                return this.y < -this.size || this.x < -this.size || this.x > canvas.width + this.size;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Draw cow in spacesuit
                this.drawSpacesuitCow();
                
                ctx.restore();
            }
            
            drawSpacesuitCow() {
                // Spacesuit body
                ctx.fillStyle = '#aaccff';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 0.5, this.size * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Helmet
                ctx.fillStyle = 'rgba(170, 204, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(0, -this.size * 0.2, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#6699ff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Cow head inside helmet
                ctx.fillStyle = this.colorVariation === 0 ? '#8B4513' : 
                                  this.colorVariation === 1 ? '#A0522D' : '#D2B48C';
                ctx.beginPath();
                ctx.ellipse(0, -this.size * 0.2, this.size * 0.2, this.size * 0.15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Ears
                ctx.fillStyle = this.colorVariation === 0 ? '#A0522D' : 
                                this.colorVariation === 1 ? '#8B4513' : '#CD853F';
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.15, -this.size * 0.3, this.size * 0.08, this.size * 0.12, -0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.size * 0.15, -this.size * 0.3, this.size * 0.08, this.size * 0.12, 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Legs (animation frames)
                const legY = this.size * 0.4 + Math.sin(this.frame * Math.PI / 2) * this.size * 0.1;
                
                ctx.fillStyle = '#aaccff';
                // Front legs
                ctx.fillRect(-this.size * 0.3, this.size * 0.2, this.size * 0.15, legY);
                ctx.fillRect(this.size * 0.15, this.size * 0.2, this.size * 0.15, legY);
                // Back legs
                ctx.fillRect(-this.size * 0.3, this.size * 0.2 + legY, this.size * 0.15, this.size * 0.3);
                ctx.fillRect(this.size * 0.15, this.size * 0.2 + legY, this.size * 0.15, this.size * 0.3);
                
                // Udder (because it's a cow!)
                ctx.fillStyle = '#ffccff';
                ctx.beginPath();
                ctx.ellipse(0, this.size * 0.5, this.size * 0.1, this.size * 0.05, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Spacesuit details
                ctx.strokeStyle = '#3399ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -this.size * 0.6);
                ctx.lineTo(0, -this.size * 0.3);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, -this.size * 0.6, this.size * 0.1, 0, Math.PI * 2);
                ctx.stroke();
                
                // Oxygen tank
                ctx.fillStyle = '#6688aa';
                ctx.fillRect(this.size * 0.4, -this.size * 0.2, this.size * 0.15, this.size * 0.4);
                ctx.strokeRect(this.size * 0.4, -this.size * 0.2, this.size * 0.15, this.size * 0.4);
                
                // Eyes (animate blinking)
                if (this.frame !== 2 || this.hit) {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-this.size * 0.08, -this.size * 0.25, this.size * 0.03, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(this.size * 0.08, -this.size * 0.25, this.size * 0.03, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-this.size * 0.08, -this.size * 0.25, this.size * 0.01, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(this.size * 0.08, -this.size * 0.25, this.size * 0.01, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // If hit, show cracks in helmet
                if (this.hit) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, -this.size * 0.2, this.size * 0.35, 0, Math.PI * 1.5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(this.size * 0.1, -this.size * 0.4);
                    ctx.lineTo(-this.size * 0.15, -this.size * 0.3);
                    ctx.stroke();
                }
            }
        }
        
        // Explosion class
        class Explosion {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.particles = [];
                this.duration = 30;
                
                // Create explosion particles
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: 0,
                        y: 0,
                        speedX: Math.random() * 6 - 3,
                        speedY: Math.random() * 6 - 3,
                        size: Math.random() * 3 + 1,
                        color: `hsl(${Math.random() * 60 + 180}, 100%, ${Math.random() * 30 + 50}%)`,
                        life: Math.random() * 10 + this.duration - 10
                    });
                }
            }
            
            update() {
                this.duration--;
                
                for (let particle of this.particles) {
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    particle.speedY += 0.1;
                    particle.life--;
                }
                
                return this.duration <= 0;
            }
            
            draw() {
                for (let particle of this.particles) {
                    if (particle.life > 0) {
                        const alpha = particle.life / this.duration;
                        ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
                        ctx.beginPath();
                        ctx.arc(
                            this.x + particle.x,
                            this.y + particle.y,
                            particle.size * alpha,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }
        }
        
        // Shot class
        class Shot {
            constructor(x, y, targetX, targetY) {
                this.x = x;
                this.y = y;
                this.targetX = targetX;
                this.targetY = targetY;
                this.speed = 15;
                this.size = 5;
                this.life = 50;
                
                // Calculate direction
                const dx = targetX - x;
                const dy = targetY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                
                return this.life <= 0 || 
                       this.x < 0 || 
                       this.x > canvas.width || 
                       this.y < 0 || 
                       this.y > canvas.height;
            }
            
            draw() {
                ctx.fillStyle = '#3399ff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Trail
                ctx.strokeStyle = 'rgba(51, 153, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x - this.vx * 2, this.y - this.vy * 2);
                ctx.lineTo(this.x, this.y);
                ctx.stroke();
            }
        }
        
        // Draw space station
        function drawSpaceStation(x, y, size, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            // Main structure
            ctx.fillStyle = '#334d66';
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // Ring
            ctx.strokeStyle = '#6699cc';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2);
            ctx.stroke();
            
            // Details
            ctx.fillStyle = '#6688aa';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.arc(
                    Math.cos(angle) * size * 0.4,
                    Math.sin(angle) * size * 0.4,
                    size * 0.05,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
            
            // Docking ports
            ctx.fillStyle = '#445566';
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                ctx.beginPath();
                ctx.arc(
                    Math.cos(angle) * size * 0.7,
                    Math.sin(angle) * size * 0.7,
                    size * 0.1,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // Draw background stars
        function drawBackground() {
            // Dark space gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000033');
            gradient.addColorStop(1, '#001133');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw distant nebula
            ctx.fillStyle = 'rgba(0, 40, 80, 0.2)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.3, canvas.height * 0.2, canvas.width * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(canvas.width * 0.7, canvas.height * 0.7, canvas.width * 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw stars
            ctx.fillStyle = 'white';
            for (let star of backgroundStars) {
                const alpha = Math.min(1, star.brightness * (1 + Math.sin(Date.now() * 0.001 * star.speed) * 0.3));
                ctx.globalAlpha = alpha;
                ctx.fillRect(star.x, star.y, star.size, star.size);
            }
            ctx.globalAlpha = 1;
            
            // Draw space stations
            for (let station of spaceStations) {
                drawSpaceStation(station.x, station.y, station.size, station.rotation);
                station.rotation += station.rotationSpeed;
            }
        }
        
        // Check if point is inside cow
        function isPointInCow(x, y, cow) {
            ctx.save();
            ctx.translate(cow.x, cow.y);
            ctx.rotate(cow.rotation);
            
            // Simplified ellipse collision detection
            const dx = x - cow.x;
            const dy = y - cow.y;
            const rotatedX = dx * Math.cos(-cow.rotation) - dy * Math.sin(-cow.rotation);
            const rotatedY = dx * Math.sin(-cow.rotation) + dy * Math.cos(-cow.rotation);
            
            // Check if point is within the cow's bounding ellipse
            const normalizedX = rotatedX / (cow.size * 0.5);
            const normalizedY = rotatedY / (cow.size * 0.7);
            const distance = normalizedX * normalizedX + normalizedY * normalizedY;
            
            ctx.restore();
            return distance <= 1;
        }
        
        // Game loop
        function gameLoop(timestamp) {
            if (!gameRunning) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawBackground();
            
            // Spawn new cows
            if (timestamp - lastCowTime > cowInterval) {
                cows.push(new Cow());
                lastCowTime = timestamp;
            }
            
            // Increase difficulty over time
            if (timestamp - lastDifficultyIncrease > difficultyIncreaseInterval) {
                cowInterval = Math.max(300, cowInterval * 0.95);
                lastDifficultyIncrease = timestamp;
            }
            
            // Update and draw cows
            for (let i = cows.length - 1; i >= 0; i--) {
                const cow = cows[i];
                const shouldRemove = cow.update();
                
                if (shouldRemove) {
                    cows.splice(i, 1);
                    
                    // If cow leaves screen without being hit, game over
                    if (!cow.hit) {
                        gameOver();
                        return;
                    }
                } else {
                    cow.draw();
                }
            }
            
            // Update and draw shots
            for (let i = shots.length - 1; i >= 0; i--) {
                const shot = shots[i];
                const shouldRemove = shot.update();
                
                if (shouldRemove) {
                    shots.splice(i, 1);
                } else {
                    shot.draw();
                }
            }
            
            // Update and draw explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                const shouldRemove = explosion.update();
                
                if (shouldRemove) {
                    explosions.splice(i, 1);
                } else {
                    explosion.draw();
                }
            }
            
            // Display score and ammo
            scoreDisplay.textContent = `Score: ${score}`;
            ammoDisplay.textContent = ammo === Infinity ? "Ammo: ∞" : `Ammo: ${ammo}`;
            
            requestAnimationFrame(gameLoop);
        }
        
        // Handle mouse/touch shooting
        function handleShoot(e) {
            if (!gameRunning) return;
            
            // Get click/touch position
            let clientX, clientY;
            if (e.type === 'touchstart' || e.type === 'touchmove') {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            // Check if we hit any cows
            let hitCow = false;
            for (let i = cows.length - 1; i >= 0; i--) {
                const cow = cows[i];
                if (!cow.hit && isPointInCow(x, y, cow)) {
                    cow.hit = true;
                    explosions.push(new Explosion(cow.x, cow.y, cow.size));
                    score += Math.floor(100 - cow.size / 2);
                    hitCow = true;
                    break;
                }
            }
            
            // Create shot from bottom center to target
            if (ammo > 0 || ammo === Infinity) {
                shots.push(new Shot(canvas.width / 2, canvas.height, x, y));
                if (ammo !== Infinity) ammo--;
            }
            
            // Vibrate on hit if supported
            if (hitCow && navigator.vibrate) {
                navigator.vibrate(50);
            }
            
            // Play sound if supported
            playShootSound();
        }
        
        // Simple sound effects
        function playShootSound() {
            if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                try {
                    const audioContext = new (AudioContext || webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 800;
                    gainNode.gain.value = 0.1;
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            }
        }
        
        function playExplosionSound() {
            if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                try {
                    const audioContext = new (AudioContext || webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                    gainNode.gain.value = 0.1;
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    console.log('Audio error:', e);
                }
            }
        }
        
        // Start game
        function startGame() {
            score = 0;
            ammo = Infinity;
            cows = [];
            explosions = [];
            shots = [];
            lastCowTime = 0;
            cowInterval = 1500;
            lastDifficultyIncrease = 0;
            gameStartTime = Date.now();
            
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            crosshair.style.display = 'block';
            
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            crosshair.style.display = 'none';
            
            document.getElementById('finalScoreText').textContent = `You scored: ${score} points`;
            gameOverScreen.style.display = 'flex';
            
            // Send score to Telegram
            if (tg && tg.sendData) {
                tg.sendData(JSON.stringify({ score: score }));
            }
        }
        
        // Initialize game
        function init() {
            resizeCanvas();
            initBackground();
            
            // Event listeners
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', handleShoot);
            canvas.addEventListener('touchstart', handleShoot);
            
            // Move crosshair with mouse/touch
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                crosshair.style.left = `${e.clientX - rect.left - 15}px`;
                crosshair.style.top = `${e.clientY - rect.top - 15}px`;
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                crosshair.style.left = `${e.touches[0].clientX - rect.left - 15}px`;
                crosshair.style.top = `${e.touches[0].clientY - rect.top - 15}px`;
            });
            
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', startGame);
        }
        
        // Start the game when everything is loaded
        window.addEventListener('load', init);
    </script>
</body>
</html>