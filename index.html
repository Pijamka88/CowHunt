<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Cow Hunt</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
            touch-action: manipulation;
            user-select: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        #backgroundCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 50, 0.8);
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        
        #menu h1 {
            font-size: 3rem;
            margin-bottom: 2rem;
            color: #ffcc00;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.7);
        }
        
        #menu button {
            padding: 15px 30px;
            font-size: 1.5rem;
            background: linear-gradient(to bottom, #4a6bff, #1a3dff);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 0 15px rgba(74, 107, 255, 0.7);
            transition: all 0.3s;
        }
        
        #menu button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(74, 107, 255, 0.9);
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            z-index: 2;
            color: white;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px black;
        }
        
        #bottomUI {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            z-index: 2;
            color: white;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px black;
        }
        
        #ammoDisplay {
            display: flex;
            align-items: center;
        }
        
        #ammoCount {
            margin: 0 10px;
        }
        
        #reloadMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.5rem;
            z-index: 5;
            display: none;
        }
        
        .heart {
            color: red;
            font-size: 1.5rem;
            margin: 0 3px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="backgroundCanvas"></canvas>
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="score">Score: 0</div>
            <div id="time">Time: 60</div>
            <div id="life">Life: <span class="heart">♥</span><span class="heart">♥</span><span class="heart">♥</span></div>
        </div>
        <div id="bottomUI">
            <div id="ammoDisplay">
                <div>Ammo:</div>
                <div id="ammoCount">5/5</div>
                <div id="ammoBar">|||||</div>
            </div>
            <div id="hits">Hits: 0/0</div>
        </div>
        <div id="reloadMessage">Reloading...</div>
        <div id="menu">
            <h1>Cosmic Cow Hunt</h1>
            <button id="startGame">Start Game</button>
            <button id="howToPlay">How to Play</button>
        </div>
    </div>

    <script>
        // Game variables
        const gameState = {
            score: 0,
            timeLeft: 60,
            lives: 3,
            ammo: 5,
            maxAmmo: 5,
            hits: 0,
            shots: 0,
            gameActive: false,
            reloading: false,
            cows: [],
            planets: [],
            stars: [],
            explosions: [],
            lastCowTime: 0,
            cowInterval: 1000,
            lastPlanetTime: 0,
            planetInterval: 5000,
            lastStarTime: 0,
            starInterval: 100,
            backgroundOffset: 0,
            reloadStartTime: 0,
            reloadDuration: 2000
        };

        // Canvas setup
        const backgroundCanvas = document.getElementById('backgroundCanvas');
        const bgCtx = backgroundCanvas.getContext('2d');
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');

        // UI elements
        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');
        const lifeElement = document.getElementById('life');
        const ammoCountElement = document.getElementById('ammoCount');
        const ammoBarElement = document.getElementById('ammoBar');
        const hitsElement = document.getElementById('hits');
        const reloadMessage = document.getElementById('reloadMessage');
        const menuElement = document.getElementById('menu');
        const startButton = document.getElementById('startGame');
        const howToPlayButton = document.getElementById('howToPlay');

        // Resize canvases to window size
        function resizeCanvases() {
            gameCanvas.width = window.innerWidth;
            gameCanvas.height = window.innerHeight;
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        // Game objects
        class Cow {
            constructor() {
                this.width = 80;
                this.height = 50;
                this.x = Math.random() < 0.5 ? -this.width : gameCanvas.width;
                this.y = Math.random() * (gameCanvas.height - this.height);
                this.speedX = (Math.random() * 3 + 1) * (this.x < 0 ? 1 : -1);
                this.speedY = (Math.random() * 2 - 1) * 0.5;
                this.alive = true;
                this.frame = 0;
                this.maxFrames = 4;
                this.animationSpeed = 0.2;
                this.wingFrame = 0;
                this.wingDirection = 1;
                this.wingSpeed = 0.1;
                this.hit = false;
                this.deathFrame = 0;
                this.maxDeathFrames = 10;
                this.rotation = 0;
                this.rotationSpeed = (Math.random() * 5 + 5) * (Math.random() < 0.5 ? 1 : -1);
                this.fallSpeed = 0;
                this.spots = this.generateSpots();
            }

            generateSpots() {
                const spots = [];
                const spotCount = Math.floor(Math.random() * 5) + 3;
                for (let i = 0; i < spotCount; i++) {
                    spots.push({
                        x: Math.random() * this.width - this.width/2,
                        y: Math.random() * this.height - this.height/2,
                        width: Math.random() * 15 + 10,
                        height: Math.random() * 10 + 5,
                        rotation: Math.random() * Math.PI
                    });
                }
                return spots;
            }

            update() {
                if (this.hit) {
                    this.deathFrame += 0.5;
                    this.rotation += this.rotationSpeed;
                    this.fallSpeed += 0.2;
                    this.y += this.fallSpeed;
                    if (this.deathFrame >= this.maxDeathFrames) {
                        return false;
                    }
                } else {
                    this.x += this.speedX;
                    this.y += this.speedY;
                    this.frame = (this.frame + this.animationSpeed) % this.maxFrames;
                    
                    this.wingFrame += this.wingSpeed * this.wingDirection;
                    if (this.wingFrame >= 1 || this.wingFrame <= 0) {
                        this.wingDirection *= -1;
                    }
                    
                    // Remove if off screen
                    if ((this.speedX > 0 && this.x > gameCanvas.width) || 
                        (this.speedX < 0 && this.x < -this.width)) {
                        return false;
                    }
                }
                return true;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                
                if (this.hit) {
                    ctx.rotate(this.rotation * Math.PI / 180);
                    this.drawDeadCow(ctx);
                } else {
                    this.drawAliveCow(ctx);
                }
                
                ctx.restore();
            }

            drawAliveCow(ctx) {
                // Body
                ctx.fillStyle = '#f0f0f0';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Spots
                ctx.fillStyle = '#8B4513';
                for (const spot of this.spots) {
                    ctx.save();
                    ctx.translate(spot.x, spot.y);
                    ctx.rotate(spot.rotation);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, spot.width/2, spot.height/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Head
                ctx.fillStyle = '#f0f0f0';
                ctx.beginPath();
                ctx.ellipse(this.width / 4, -this.height / 4, this.width / 4, this.height / 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(this.width / 4 + 5, -this.height / 4 - 5, 3, 0, Math.PI * 2);
                ctx.arc(this.width / 4 + 15, -this.height / 4 - 5, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyelashes
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(this.width / 4 + 5 + i*2, -this.height / 4 - 8);
                    ctx.lineTo(this.width / 4 + 5 + i*2, -this.height / 4 - 5);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(this.width / 4 + 15 + i*2, -this.height / 4 - 8);
                    ctx.lineTo(this.width / 4 + 15 + i*2, -this.height / 4 - 5);
                    ctx.stroke();
                }
                
                // Nose
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(this.width / 4 + 10, -this.height / 4 + 5, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Nostrils
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(this.width / 4 + 8, -this.height / 4 + 5, 1, 0, Math.PI * 2);
                ctx.arc(this.width / 4 + 12, -this.height / 4 + 5, 1, 0, Math.PI * 2);
                ctx.fill();
                
                // Wings animation
                const wingY = this.wingFrame * 15;
                
                // Left wing
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.moveTo(-this.width / 2, 0);
                ctx.quadraticCurveTo(-this.width / 2 - 30, -this.height / 2 - wingY, -this.width / 4, -this.height / 2 - wingY);
                ctx.quadraticCurveTo(-this.width / 8, -this.height / 4 - wingY / 2, -this.width / 2, 0);
                ctx.fill();
                
                // Right wing
                ctx.beginPath();
                ctx.moveTo(-this.width / 2, 0);
                ctx.quadraticCurveTo(-this.width / 2 - 30, this.height / 2 + wingY, -this.width / 4, this.height / 2 + wingY);
                ctx.quadraticCurveTo(-this.width / 8, this.height / 4 + wingY / 2, -this.width / 2, 0);
                ctx.fill();
                
                // Scafander details
                ctx.strokeStyle = 'lightblue';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.width / 2 - 5, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(this.width / 4, -this.height / 4, this.width / 4 - 5, 0, Math.PI * 2);
                ctx.stroke();
                
                // Helmet reflection
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(this.width / 4 + 5, -this.height / 4 - 5, 3, Math.PI * 0.8, Math.PI * 1.2);
                ctx.stroke();
            }

            drawDeadCow(ctx) {
                const deathProgress = this.deathFrame / this.maxDeathFrames;
                const alpha = 1 - deathProgress * 0.7;
                
                // Body
                ctx.fillStyle = `rgba(240, 240, 240, ${alpha})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Spots
                ctx.fillStyle = `rgba(139, 69, 19, ${alpha})`;
                for (const spot of this.spots) {
                    ctx.save();
                    ctx.translate(spot.x, spot.y);
                    ctx.rotate(spot.rotation);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, spot.width/2, spot.height/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Head
                ctx.fillStyle = `rgba(240, 240, 240, ${alpha})`;
                ctx.beginPath();
                ctx.ellipse(this.width / 4, -this.height / 4, this.width / 4, this.height / 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // X eyes
                ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.width / 4 + 2, -this.height / 4 - 6);
                ctx.lineTo(this.width / 4 + 8, -this.height / 4 - 2);
                ctx.moveTo(this.width / 4 + 8, -this.height / 4 - 6);
                ctx.lineTo(this.width / 4 + 2, -this.height / 4 - 2);
                
                ctx.moveTo(this.width / 4 + 12, -this.height / 4 - 6);
                ctx.lineTo(this.width / 4 + 18, -this.height / 4 - 2);
                ctx.moveTo(this.width / 4 + 18, -this.height / 4 - 6);
                ctx.lineTo(this.width / 4 + 12, -this.height / 4 - 2);
                ctx.stroke();
                
                // Cracked helmet
                ctx.strokeStyle = `rgba(100, 100, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.width / 4, -this.height / 4, this.width / 4 - 5, 0, Math.PI * 2);
                ctx.stroke();
                
                // Crack lines
                ctx.beginPath();
                ctx.moveTo(this.width / 4 - 10, -this.height / 4 - 10);
                ctx.lineTo(this.width / 4 + 5, -this.height / 4 + 5);
                ctx.lineTo(this.width / 4 + 15, -this.height / 4 - 5);
                ctx.stroke();
                
                // Broken helmet pieces
                ctx.strokeStyle = `rgba(100, 100, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.width / 4 + 10, -this.height / 4 - 10, 5, 0, Math.PI * 1.5);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(this.width / 4 - 5, -this.height / 4 + 5, 3, Math.PI, Math.PI * 1.8);
                ctx.stroke();
            }

            isHit(x, y) {
                if (this.hit) return false;
                
                // Simple ellipse collision detection
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                const radiusX = this.width / 2;
                const radiusY = this.height / 2;
                
                const normalizedX = (x - centerX) / radiusX;
                const normalizedY = (y - centerY) / radiusY;
                
                return normalizedX * normalizedX + normalizedY * normalizedY <= 1;
            }
        }

        class Planet {
            constructor() {
                this.size = Math.random() * 100 + 80;
                this.x = Math.random() * gameCanvas.width;
                this.y = Math.random() * gameCanvas.height * 0.6;
                this.speed = Math.random() * 0.2 + 0.1;
                this.color1 = Math.random() < 0.5 ? 
                    `hsl(${Math.random() * 40 + 200}, ${Math.random() * 30 + 50}%, ${Math.random() * 20 + 40}%)` : 
                    `hsl(${Math.random() * 30 + 30}, ${Math.random() * 30 + 50}%, ${Math.random() * 20 + 40}%)`;
                this.color2 = this.generateComplementaryColor(this.color1);
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.005;
                this.details = this.generatePlanetDetails();
            }

            generateComplementaryColor(hslColor) {
                const matches = hslColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (!matches) return hslColor;
                
                let h = parseInt(matches[1]);
                const s = parseInt(matches[2]);
                const l = parseInt(matches[3]);
                
                h = (h + 30) % 360;
                return `hsl(${h}, ${s}%, ${l}%)`;
            }

            generatePlanetDetails() {
                const details = [];
                const detailCount = Math.floor(Math.random() * 5) + 3;
                
                for (let i = 0; i < detailCount; i++) {
                    details.push({
                        type: Math.random() < 0.7 ? 'crater' : 'mountain',
                        x: Math.random() * this.size * 2 - this.size,
                        y: Math.random() * this.size * 2 - this.size,
                        size: Math.random() * this.size * 0.2 + this.size * 0.05,
                        colorVariation: Math.random() * 0.3 - 0.15
                    });
                }
                
                return details;
            }

            update() {
                this.y += this.speed;
                this.rotation += this.rotationSpeed;
                if (this.y > gameCanvas.height + this.size) {
                    return false;
                }
                return true;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Planet gradient
                const gradient = ctx.createRadialGradient(
                    -this.size * 0.3, -this.size * 0.3, 0,
                    -this.size * 0.3, -this.size * 0.3, this.size * 1.5
                );
                gradient.addColorStop(0, this.color1);
                gradient.addColorStop(1, this.color2);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Planet details
                for (const detail of this.details) {
                    const distance = Math.sqrt(detail.x * detail.x + detail.y * detail.y);
                    if (distance > this.size) continue;
                    
                    const angle = Math.atan2(detail.y, detail.x);
                    const surfaceX = Math.cos(angle) * this.size;
                    const surfaceY = Math.sin(angle) * this.size;
                    
                    if (detail.type === 'crater') {
                        // Crater shadow
                        ctx.fillStyle = this.adjustColor(this.color1, -0.2 + detail.colorVariation);
                        ctx.beginPath();
                        ctx.arc(
                            surfaceX * 0.9,
                            surfaceY * 0.9,
                            detail.size * 0.8,
                            0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // Crater rim
                        ctx.strokeStyle = this.adjustColor(this.color1, 0.1 + detail.colorVariation);
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(
                            surfaceX,
                            surfaceY,
                            detail.size,
                            0, Math.PI * 2
                        );
                        ctx.stroke();
                    } else {
                        // Mountain
                        ctx.fillStyle = this.adjustColor(this.color1, 0.15 + detail.colorVariation);
                        ctx.beginPath();
                        ctx.moveTo(surfaceX, surfaceY);
                        ctx.lineTo(
                            surfaceX + Math.cos(angle + Math.PI/2) * detail.size * 0.5,
                            surfaceY + Math.sin(angle + Math.PI/2) * detail.size * 0.5
                        );
                        ctx.lineTo(
                            surfaceX + Math.cos(angle) * detail.size * 1.5,
                            surfaceY + Math.sin(angle) * detail.size * 1.5
                        );
                        ctx.lineTo(
                            surfaceX + Math.cos(angle - Math.PI/2) * detail.size * 0.5,
                            surfaceY + Math.sin(angle - Math.PI/2) * detail.size * 0.5
                        );
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                
                // Planet terminator
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, Math.PI * 0.4, Math.PI * 0.6);
                ctx.stroke();
                
                ctx.restore();
            }

            adjustColor(color, amount) {
                const matches = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (!matches) return color;
                
                let h = parseInt(matches[1]);
                let s = parseInt(matches[2]);
                let l = parseInt(matches[3]);
                
                l = Math.max(0, Math.min(100, l + amount * 100));
                return `hsl(${h}, ${s}%, ${l}%)`;
            }
        }

        class Star {
            constructor() {
                this.x = Math.random() * gameCanvas.width;
                this.y = Math.random() * gameCanvas.height;
                this.size = Math.random() * 6 + 4;
                this.color = Math.random() < 0.7 ? 'rgba(100, 200, 255, 0.9)' : 'rgba(255, 215, 0, 0.9)';
                this.speed = Math.random() * 0.5 + 0.1;
                this.angle = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;
                this.twinkleSpeed = Math.random() * 0.05 + 0.01;
                this.twinklePhase = Math.random() * Math.PI * 2;
                this.baseSize = this.size;
            }

            update() {
                this.y += this.speed;
                this.angle += this.rotationSpeed;
                this.twinklePhase += this.twinkleSpeed;
                this.size = this.baseSize * (0.8 + Math.sin(this.twinklePhase) * 0.2);
                
                if (this.y > gameCanvas.height) {
                    this.y = -5;
                    this.x = Math.random() * gameCanvas.width;
                }
                return true;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = this.color;
                
                // Draw 4-pointed star with glow
                ctx.shadowColor = this.color;
                ctx.shadowBlur = this.size * 2;
                
                ctx.beginPath();
                for (let i = 0; i < 4; i++) {
                    const angle = i * Math.PI / 2;
                    ctx.lineTo(Math.cos(angle) * this.size, Math.sin(angle) * this.size);
                    ctx.lineTo(Math.cos(angle + Math.PI / 4) * this.size * 0.5, Math.sin(angle + Math.PI / 4) * this.size * 0.5);
                }
                ctx.closePath();
                ctx.fill();
                
                // Bright center
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                this.duration = 30;
                this.frame = 0;
                
                // Create explosion particles
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        x: 0,
                        y: 0,
                        speedX: (Math.random() - 0.5) * 6,
                        speedY: (Math.random() - 0.5) * 6,
                        size: Math.random() * 6 + 3,
                        color: `rgba(255, ${Math.floor(Math.random() * 100 + 155)}, 0, 1)`,
                        life: Math.random() * 10 + 20
                    });
                }
            }

            update() {
                this.frame++;
                if (this.frame >= this.duration) {
                    return false;
                }
                return true;
            }

            draw(ctx) {
                const progress = this.frame / this.duration;
                
                for (const particle of this.particles) {
                    if (this.frame > particle.life) continue;
                    
                    const particleProgress = this.frame / particle.life;
                    const alpha = 1 - particleProgress;
                    const x = this.x + particle.x + particle.speedX * this.frame;
                    const y = this.y + particle.y + particle.speedY * this.frame;
                    
                    ctx.fillStyle = particle.color.replace('1)', `${alpha})`);
                    ctx.beginPath();
                    ctx.arc(x, y, particle.size * (1 - particleProgress * 0.7), 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Game functions
        function startGame() {
            gameState.score = 0;
            gameState.timeLeft = 60;
            gameState.lives = 3;
            gameState.ammo = 5;
            gameState.hits = 0;
            gameState.shots = 0;
            gameState.gameActive = true;
            gameState.cows = [];
            gameState.planets = [];
            gameState.stars = [];
            gameState.explosions = [];
            gameState.lastCowTime = 0;
            gameState.lastPlanetTime = 0;
            gameState.lastStarTime = 0;
            gameState.reloading = false;
            
            updateUI();
            menuElement.style.display = 'none';
            
            // Initial stars
            for (let i = 0; i < 50; i++) {
                gameState.stars.push(new Star());
            }
            
            // Start game loop
            lastTime = performance.now();
            gameLoop(lastTime);
        }

        function endGame() {
            gameState.gameActive = false;
            menuElement.style.display = 'flex';
            document.querySelector('#menu h1').textContent = `Game Over! Score: ${gameState.score}`;
        }

        function updateUI() {
            scoreElement.textContent = `Score: ${gameState.score}`;
            timeElement.textContent = `Time: ${Math.max(0, Math.floor(gameState.timeLeft))}`;
            
            // Update lives (hearts)
            let hearts = '';
            for (let i = 0; i < 3; i++) {
                hearts += `<span class="heart" style="color: ${i < gameState.lives ? 'red' : 'gray'}">♥</span>`;
            }
            lifeElement.innerHTML = `Life: ${hearts}`;
            
            ammoCountElement.textContent = `${gameState.ammo}/${gameState.maxAmmo}`;
            ammoBarElement.textContent = '|'.repeat(gameState.ammo) + '_'.repeat(gameState.maxAmmo - gameState.ammo);
            hitsElement.textContent = `Hits: ${gameState.hits}/${gameState.shots}`;
        }

        function shoot(x, y) {
            if (!gameState.gameActive || gameState.reloading) return;
            
            gameState.shots++;
            
            // Check if hit any cow
            let hit = false;
            for (const cow of gameState.cows) {
                if (cow.isHit(x, y)) {
                    cow.hit = true;
                    gameState.score += 10;
                    gameState.hits++;
                    hit = true;
                    gameState.explosions.push(new Explosion(x, y));
                    break;
                }
            }
            
            // Play sound (in a real implementation, you would use Howler.js or similar)
            // const sound = hit ? document.getElementById('hitSound') : document.getElementById('shotSound');
            // sound.currentTime = 0;
            // sound.play();
            
            // Decrease ammo
            gameState.ammo--;
            updateUI();
            
            // Check for reload
            if (gameState.ammo <= 0) {
                startReload();
            }
        }

        function startReload() {
            gameState.reloading = true;
            gameState.reloadStartTime = performance.now();
            reloadMessage.style.display = 'block';
        }

        function finishReload() {
            gameState.ammo = gameState.maxAmmo;
            gameState.reloading = false;
            reloadMessage.style.display = 'none';
            updateUI();
        }

        function spawnCow() {
            if (Math.random() < 0.7) { // 70% chance to spawn a cow
                gameState.cows.push(new Cow());
            }
        }

        function spawnPlanet() {
            if (gameState.planets.length < 3) { // Max 3 planets at a time
                const newPlanet = new Planet();
                
                // Check if new planet overlaps with existing ones
                let canSpawn = true;
                for (const planet of gameState.planets) {
                    const dx = newPlanet.x - planet.x;
                    const dy = newPlanet.y - planet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < newPlanet.size + planet.size) {
                        canSpawn = false;
                        break;
                    }
                }
                
                if (canSpawn) {
                    gameState.planets.push(newPlanet);
                }
            }
        }

        function spawnStar() {
            if (gameState.stars.length < 100) { // Max 100 stars
                gameState.stars.push(new Star());
            }
        }

        // Event listeners
        gameCanvas.addEventListener('click', (e) => {
            const rect = gameCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            shoot(x, y);
        });

        gameCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = gameCanvas.getBoundingClientRect();
            const x = e.touches[0].clientX - rect.left;
            const y = e.touches[0].clientY - rect.top;
            shoot(x, y);
        });

        startButton.addEventListener('click', startGame);
        howToPlayButton.addEventListener('click', () => {
            alert("How to Play:\n\n- Shoot the flying cosmic cows by tapping/clicking on them\n- You have 5 shots before needing to reload\n- Each hit gives you 10 points\n- You have 60 seconds and 3 lives\n- Don't let the cows escape!");
        });

        // Background drawing
        function drawBackground() {
            // Cosmic gradient background
            const gradient = bgCtx.createLinearGradient(0, 0, 0, backgroundCanvas.height);
            gradient.addColorStop(0, '#000033');
            gradient.addColorStop(0.5, '#000066');
            gradient.addColorStop(1, '#000022');
            bgCtx.fillStyle = gradient;
            bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            
            // Nebula effect
            bgCtx.fillStyle = 'rgba(50, 50, 150, 0.1)';
            for (let i = 0; i < 5; i++) {
                const size = Math.random() * 400 + 200;
                const x = Math.random() * backgroundCanvas.width;
                const y = Math.random() * backgroundCanvas.height;
                bgCtx.beginPath();
                bgCtx.arc(x, y, size, 0, Math.PI * 2);
                bgCtx.fill();
            }
        }

        // Game loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Clear canvas
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            
            // Update game state
            if (gameState.gameActive) {
                // Update time
                gameState.timeLeft -= deltaTime / 1000;
                if (gameState.timeLeft <= 0) {
                    endGame();
                }
                
                // Spawn cows
                if (timestamp - gameState.lastCowTime > gameState.cowInterval) {
                    gameState.lastCowTime = timestamp;
                    spawnCow();
                    // Gradually increase difficulty by decreasing spawn interval
                    gameState.cowInterval = Math.max(300, gameState.cowInterval - 10);
                }
                
                // Spawn planets
                if (timestamp - gameState.lastPlanetTime > gameState.planetInterval) {
                    gameState.lastPlanetTime = timestamp;
                    spawnPlanet();
                }
                
                // Spawn stars
                if (timestamp - gameState.lastStarTime > gameState.starInterval) {
                    gameState.lastStarTime = timestamp;
                    spawnStar();
                }
                
                // Handle reloading
                if (gameState.reloading && timestamp - gameState.reloadStartTime > gameState.reloadDuration) {
                    finishReload();
                }
                
                // Update cows
                gameState.cows = gameState.cows.filter(cow => cow.update());
                
                // Check for escaped cows (reduce lives)
                for (const cow of gameState.cows) {
                    if (!cow.hit && ((cow.speedX > 0 && cow.x > gameCanvas.width) || 
                                     (cow.speedX < 0 && cow.x < -cow.width))) {
                        gameState.lives--;
                        updateUI();
                        if (gameState.lives <= 0) {
                            endGame();
                        }
                    }
                }
                
                // Update planets
                gameState.planets = gameState.planets.filter(planet => planet.update());
                
                // Update stars
                gameState.stars = gameState.stars.filter(star => star.update());
                
                // Update explosions
                gameState.explosions = gameState.explosions.filter(explosion => explosion.update());
                
                // Update UI
                updateUI();
            }
            
            // Draw background
            drawBackground();
            
            // Draw planets
            for (const planet of gameState.planets) {
                planet.draw(bgCtx);
            }
            
            // Draw stars
            for (const star of gameState.stars) {
                star.draw(bgCtx);
            }
            
            // Draw cows
            for (const cow of gameState.cows) {
                cow.draw(ctx);
            }
            
            // Draw explosions
            for (const explosion of gameState.explosions) {
                explosion.draw(ctx);
            }
            
            // Continue game loop
            if (gameState.gameActive || gameState.explosions.length > 0) {
                requestAnimationFrame(gameLoop);
            }
        }

        // Initial background draw
        drawBackground();
    </script>
</body>
</html>