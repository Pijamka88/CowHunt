<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>City Chase</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #121212;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #menu, #game {
            padding: 20px;
            text-align: center;
        }
        #menu {
            display: flex;
            flex-direction: column;
            justify-content: center;
            height: 100%;
        }
        #game {
            display: none;
            flex: 1;
            flex-direction: column;
        }
        button {
            background: #0078ff;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 14px 24px;
            font-size: 18px;
            margin: 10px;
            width: 80%;
            max-width: 300px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:active {
            background: #0060cc;
        }
        #ui {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: auto;
            padding: 15px 0;
            background: #1e1e1e;
            border-radius: 12px;
            width: 100%;
        }
        #stats {
            display: flex;
            justify-content: space-around;
            width: 100%;
            font-size: 18px;
        }
        #diceResult {
            font-weight: bold;
            color: #0078ff;
        }
        #remainingSteps {
            font-weight: bold;
            color: #ff9800;
        }
        #directionControls {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-top: 10px;
        }
        #grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            gap: 1px;
            flex: 1;
            background: #333;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        .cell {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #2e5d2e;
        }
        .road {
            position: absolute;
            z-index: 1;
        }
        .road-horizontal {
            width: 90%;
            height: 25%;
            background: #555;
            border: 1px solid #444;
            border-radius: 3px;
            top: 37.5%;
        }
        .road-vertical {
            height: 90%;
            width: 25%;
            background: #555;
            border: 1px solid #444;
            border-radius: 3px;
            left: 37.5%;
        }
        .intersection {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #333;
            border-radius: 50%;
            z-index: 2;
        }
        .traffic-light {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            z-index: 3;
        }
        .car {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            z-index: 4;
            transform: translate(-50%, -50%);
        }
        .player-car {
            background: #4CAF50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.7);
        }
        .police-car {
            background: #F44336;
            box-shadow: 0 0 8px rgba(244, 67, 54, 0.7);
        }
        .plant {
            position: absolute;
            font-size: 18px;
            z-index: 0;
        }
        .player-controls {
            display: flex;
            justify-content: center;
            gap: 25px;
            width: 100%;
        }
        .direction-btn {
            background: #2c2c2c;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            display: none;
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1>City Chase</h1>
        <p>Убегайте от полиции в городе!</p>
        <button id="startGame">Начать игру</button>
    </div>
    
    <div id="game">
        <div id="grid"></div>
        
        <div id="ui">
            <div id="stats">
                <div>Ходы: <span id="moveCount">0</span></div>
                <div>Кубик: <span id="diceResult">-</span></div>
                <div>Осталось: <span id="remainingSteps">0</span></div>
            </div>
            <button id="dice">Бросить кубик</button>
            
            <div id="directionControls" class="player-controls" style="display: none;">
                <button class="direction-btn" data-dir="left">←</button>
                <button class="direction-btn" data-dir="straight">↑</button>
                <button class="direction-btn" data-dir="right">→</button>
            </div>
        </div>
        
        <div class="game-over" id="gameOver">
            <h2>Игра окончена!</h2>
            <p id="gameOverMessage">Полиция поймала вас!</p>
            <button id="restartGame">Начать заново</button>
        </div>
    </div>

    <script>
        Telegram.WebApp.expand();
        Telegram.WebApp.ready();
        
        const GRID_SIZE = 10;
        let gameState = {
            player: { x: 5, y: 5, dir: 0, progress: 0, nextX: 5, nextY: 4, segmentLength: 3 },
            police: [
                { x: 0, y: 0, dir: 1, progress: 0, nextX: 1, nextY: 0, segmentLength: 3 },
                { x: 9, y: 9, dir: 3, progress: 0, nextX: 8, nextY: 9, segmentLength: 3 }
            ],
            moves: 0,
            diceValue: 0,
            remainingSteps: 0,
            gameActive: false,
            waitingForDirection: false
        };
        
        // Направления: 0=вверх, 1=вправо, 2=вниз, 3=влево
        const DIRECTIONS = [
            { dx: 0, dy: -1 }, // вверх
            { dx: 1, dy: 0 },  // вправо
            { dx: 0, dy: 1 },  // вниз
            { dx: -1, dy: 0 }  // влево
        ];
        
        // Светофоры (красный/зеленый)
        const trafficLights = Array.from({ length: GRID_SIZE }, () => 
            Array(GRID_SIZE).fill().map(() => Math.random() > 0.3 ? 'green' : 'red')
        );
        
        // Инициализация игрового поля
        function initGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    // Определяем тип ячейки (дорога или земля)
                    const isRoad = (x % 3 === 0 || y % 3 === 0) && !(x === 5 && y === 5);
                    
                    if (isRoad) {
                        // Дороги по горизонтали
                        if (x < GRID_SIZE - 1 && ((x + 1) % 3 === 0 || x % 3 === 0)) {
                            const roadH = document.createElement('div');
                            roadH.className = 'road road-horizontal';
                            cell.appendChild(roadH);
                        }
                        
                        // Дороги по вертикали
                        if (y < GRID_SIZE - 1 && ((y + 1) % 3 === 0 || y % 3 === 0)) {
                            const roadV = document.createElement('div');
                            roadV.className = 'road road-vertical';
                            cell.appendChild(roadV);
                        }
                        
                        // Перекресток
                        const intersection = document.createElement('div');
                        intersection.className = 'intersection';
                        cell.appendChild(intersection);
                        
                        // Светофор
                        if (trafficLights[y][x] === 'red') {
                            const light = document.createElement('div');
                            light.className = 'traffic-light';
                            light.style.backgroundColor = 'red';
                            light.style.top = '5px';
                            light.style.left = '5px';
                            cell.appendChild(light);
                        } else {
                            const light = document.createElement('div');
                            light.className = 'traffic-light';
                            light.style.backgroundColor = 'green';
                            light.style.top = '5px';
                            light.style.right = '5px';
                            cell.appendChild(light);
                        }
                    } else {
                        // Растения на земле
                        if (Math.random() > 0.3) {
                            const plant = document.createElement('div');
                            plant.className = 'plant';
                            plant.textContent = Math.random() > 0.5 ? '🌳' : '🌿';
                            cell.appendChild(plant);
                        }
                    }
                    
                    grid.appendChild(cell);
                }
            }
        }
        
        // Обновление позиции игрока
        function updatePlayerPosition() {
            const grid = document.getElementById('grid');
            const playerEl = document.querySelector('.car.player-car') || createPlayerElement();
            
            // Рассчитываем позицию с учетом прогресса
            const cellSize = 100 / GRID_SIZE;
            const progress = gameState.player.progress / gameState.player.segmentLength;
            let left = gameState.player.x * cellSize;
            let top = gameState.player.y * cellSize;
            
            if (gameState.player.x !== gameState.player.nextX || gameState.player.y !== gameState.player.nextY) {
                left += (gameState.player.nextX - gameState.player.x) * cellSize * progress;
                top += (gameState.player.nextY - gameState.player.y) * cellSize * progress;
            }
            
            playerEl.style.left = `${left}%`;
            playerEl.style.top = `${top}%`;
        }
        
        // Создание элемента игрока
        function createPlayerElement() {
            const playerEl = document.createElement('div');
            playerEl.className = 'car player-car';
            playerEl.textContent = '🚗';
            document.getElementById('grid').appendChild(playerEl);
            return playerEl;
        }
        
        // Обновление позиций полиции
        function updatePolicePositions() {
            const grid = document.getElementById('grid');
            
            // Удаляем существующие элементы полиции
            document.querySelectorAll('.car.police-car').forEach(el => el.remove());
            
            // Создаем новые
            gameState.police.forEach((p, i) => {
                const cellSize = 100 / GRID_SIZE;
                const progress = p.progress / p.segmentLength;
                let left = p.x * cellSize;
                let top = p.y * cellSize;
                
                if (p.x !== p.nextX || p.y !== p.nextY) {
                    left += (p.nextX - p.x) * cellSize * progress;
                    top += (p.nextY - p.y) * cellSize * progress;
                }
                
                const policeEl = document.createElement('div');
                policeEl.className = 'car police-car';
                policeEl.textContent = '🚓';
                policeEl.style.left = `${left}%`;
                policeEl.style.top = `${top}%`;
                grid.appendChild(policeEl);
            });
        }
        
        // Проверка возможности движения в любом направлении
        function canMoveAnyDirection() {
            for (let i = 0; i < 3; i++) {
                const dir = i === 0 ? gameState.player.dir : 
                            i === 1 ? (gameState.player.dir + 3) % 4 : 
                            (gameState.player.dir + 1) % 4;
                
                const nextX = gameState.player.x + DIRECTIONS[dir].dx;
                const nextY = gameState.player.y + DIRECTIONS[dir].dy;
                
                // Проверяем границы
                if (nextX < 0 || nextX >= GRID_SIZE || nextY < 0 || nextY >= GRID_SIZE) {
                    continue;
                }
                
                // Проверяем светофор на следующем перекрестке
                if (trafficLights[nextY][nextX] === 'green') {
                    return true;
                }
            }
            return false;
        }
        
        // Бросок кубика
        function rollDice() {
            if (!gameState.gameActive || gameState.waitingForDirection || gameState.remainingSteps > 0) return;
            
            gameState.diceValue = Math.floor(Math.random() * 6) + 1;
            gameState.remainingSteps = gameState.diceValue;
            gameState.moves++;
            
            document.getElementById('diceResult').textContent = gameState.diceValue;
            document.getElementById('remainingSteps').textContent = gameState.remainingSteps;
            
            // Двигаем игрока
            movePlayer();
            
            // Обновляем позицию игрока
            updatePlayerPosition();
        }
        
        // Движение игрока
        function movePlayer() {
            while (gameState.remainingSteps > 0) {
                // Если на перекрестке, ждем выбора направления
                if (gameState.player.progress === 0) {
                    // Проверяем возможность движения
                    if (!canMoveAnyDirection()) {
                        endGame("Нет возможных направлений для движения!");
                        return;
                    }
                    
                    // Генерируем случайную длину сегмента (2-4)
                    gameState.player.segmentLength = Math.floor(Math.random() * 3) + 2;
                    gameState.waitingForDirection = true;
                    document.getElementById('directionControls').style.display = 'flex';
                    return;
                }
                
                // Двигаемся по текущему сегменту
                const moveAmount = Math.min(gameState.remainingSteps, gameState.player.segmentLength - gameState.player.progress);
                gameState.player.progress += moveAmount;
                gameState.remainingSteps -= moveAmount;
                
                // Обновляем UI
                document.getElementById('remainingSteps').textContent = gameState.remainingSteps;
                
                // Достигли перекрестка?
                if (gameState.player.progress >= gameState.player.segmentLength) {
                    // Проверяем светофор на целевом перекрестке
                    if (trafficLights[gameState.player.nextY][gameState.player.nextX] === 'red') {
                        // Останавливаемся перед перекрестком
                        gameState.player.progress = gameState.player.segmentLength;
                        return;
                    }
                    
                    // Переходим на новый перекресток
                    gameState.player.x = gameState.player.nextX;
                    gameState.player.y = gameState.player.nextY;
                    gameState.player.progress = 0;
                }
            }
            
            // Если шаги закончились и не ждем направления, двигаем полицию
            if (gameState.remainingSteps === 0 && !gameState.waitingForDirection) {
                movePoliceAutomatically();
            }
        }
        
        // Автоматическое движение полиции
        function movePoliceAutomatically() {
            gameState.police.forEach(police => {
                const diceRoll = Math.floor(Math.random() * 6) + 1;
                movePolice(police, diceRoll);
            });
            updatePolicePositions();
            
            // Проверка задержания
            checkArrest();
        }
        
        // Движение полиции
        function movePolice(police, steps) {
            let remaining = steps;
            
            while (remaining > 0) {
                if (police.progress === 0) {
                    // Генерируем случайную длину сегмента (2-4)
                    police.segmentLength = Math.floor(Math.random() * 3) + 2;
                    
                    // Определяем направление к игроку
                    const dx = gameState.player.x - police.x;
                    const dy = gameState.player.y - police.y;
                    
                    if (Math.abs(dx) > Math.abs(dy)) {
                        police.dir = dx > 0 ? 1 : 3; // вправо/влево
                    } else {
                        police.dir = dy > 0 ? 2 : 0; // вниз/вверх
                    }
                    
                    // Устанавливаем следующую позицию
                    police.nextX = police.x + DIRECTIONS[police.dir].dx;
                    police.nextY = police.y + DIRECTIONS[police.dir].dy;
                    
                    // Проверка границ
                    if (police.nextX < 0 || police.nextX >= GRID_SIZE || 
                        police.nextY < 0 || police.nextY >= GRID_SIZE) {
                        police.nextX = police.x;
                        police.nextY = police.y;
                    }
                }
                
                // Двигаемся по сегменту
                const moveAmount = Math.min(remaining, police.segmentLength - police.progress);
                police.progress += moveAmount;
                remaining -= moveAmount;
                
                // Достигли перекрестка?
                if (police.progress >= police.segmentLength) {
                    police.x = police.nextX;
                    police.y = police.nextY;
                    police.progress = 0;
                }
            }
        }
        
        // Проверка задержания
        function checkArrest() {
            const playerPos = { x: Math.round(gameState.player.x), y: Math.round(gameState.player.y) };
            
            for (const police of gameState.police) {
                const policePos = { x: Math.round(police.x), y: Math.round(police.y) };
                
                // Если полиция и игрок на одной позиции
                if (playerPos.x === policePos.x && playerPos.y === policePos.y) {
                    endGame("Полиция поймала вас!");
                    return;
                }
            }
        }
        
        // Завершение игры
        function endGame(message) {
            gameState.gameActive = false;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOver').style.display = 'flex';
        }
        
        // Выбор направления игроком
        function chooseDirection(direction) {
            if (!gameState.waitingForDirection) return;
            
            const currentDir = gameState.player.dir;
            let newDir;
            
            // Определяем новое направление
            switch (direction) {
                case 'straight': newDir = currentDir; break;
                case 'left': newDir = (currentDir + 3) % 4; break; // Поворот налево (90°)
                case 'right': newDir = (currentDir + 1) % 4; break; // Поворот направо (90°)
            }
            
            // Устанавливаем новое направление и следующую позицию
            gameState.player.dir = newDir;
            gameState.player.nextX = gameState.player.x + DIRECTIONS[newDir].dx;
            gameState.player.nextY = gameState.player.y + DIRECTIONS[newDir].dy;
            
            // Проверка границ
            if (gameState.player.nextX < 0 || gameState.player.nextX >= GRID_SIZE || 
                gameState.player.nextY < 0 || gameState.player.nextY >= GRID_SIZE) {
                // Если граница, не двигаемся
                gameState.waitingForDirection = false;
                document.getElementById('directionControls').style.display = 'none';
                return;
            }
            
            // Сбрасываем флаг ожидания
            gameState.waitingForDirection = false;
            document.getElementById('directionControls').style.display = 'none';
            
            // Продолжаем движение
            movePlayer();
            updatePlayerPosition();
        }
        
        // Запуск игры
        function startGame() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('game').style.display = 'flex';
            document.getElementById('gameOver').style.display = 'none';
            
            initGrid();
            createPlayerElement();
            
            gameState = {
                player: { x: 5, y: 5, dir: 0, progress: 0, nextX: 5, nextY: 4, segmentLength: 3 },
                police: [
                    { x: 0, y: 0, dir: 1, progress: 0, nextX: 1, nextY: 0, segmentLength: 3 },
                    { x: 9, y: 9, dir: 3, progress: 0, nextX: 8, nextY: 9, segmentLength: 3 }
                ],
                moves: 0,
                diceValue: 0,
                remainingSteps: 0,
                gameActive: true,
                waitingForDirection: false
            };
            
            document.getElementById('moveCount').textContent = '0';
            document.getElementById('diceResult').textContent = '-';
            document.getElementById('remainingSteps').textContent = '0';
            updatePlayerPosition();
            updatePolicePositions();
        }
        
        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('startGame').addEventListener('click', startGame);
            document.getElementById('dice').addEventListener('click', rollDice);
            document.getElementById('restartGame').addEventListener('click', startGame);
            
            document.querySelectorAll('.direction-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    chooseDirection(btn.dataset.dir);
                });
            });
        });
    </script>
</body>
</html>
